<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DbD 1v1 Tracker — v1.1+</title>
<meta name="color-scheme" content="dark" />
<style>
  :root {
    --bg: #0f1115;
    --panel: rgba(255,255,255,0.06);
    --panel-2: rgba(255,255,255,0.08);
    --panel-border: rgba(255,255,255,0.10);
    --text: #e7e9ef;
    --text-dim: #a8adbd;
    --accent: #7c8cff;
    --accent-2: #88e0c3;
    --danger: #ff6b6b;
    --ok: #8ee68a;
    --warn: #ffcc66;
    --shadow: 0 10px 30px rgba(0,0,0,0.35);
  }

  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0; padding: 24px;
    font: 14px/1.5 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
    color: var(--text);
    background:
      radial-gradient(1200px 600px at 10% -10%, rgba(124,140,255,0.14), transparent 60%),
      radial-gradient(1200px 600px at 110% 10%, rgba(136,224,195,0.16), transparent 60%),
      var(--bg);
  }

  .wrap { max-width: 1120px; margin: 0 auto; }

  header { display:flex; align-items:center; gap:12px; margin-bottom: 12px; }
  .logo { width:38px; height:38px; border-radius:12px;
    background: linear-gradient(135deg, var(--accent), var(--accent-2)); box-shadow: var(--shadow); }
  h1 { margin: 0; font-weight: 700; letter-spacing: 0.2px; }
  .muted { color: var(--text-dim); font-size: 12px; }

  .banner {
    margin: 10px 0 18px; padding: 10px 12px;
    border-radius: 10px; border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,204,102,0.1);
    color: var(--warn); display:none;
  }

  .card {
    background: var(--panel);
    border: 1px solid var(--panel-border);
    border-radius: 14px; box-shadow: var(--shadow);
    backdrop-filter: blur(6px);
  }

  form, .controls { display: grid; gap: 12px; grid-template-columns: repeat(12, 1fr); align-items: end; }
  form { padding: 16px; }
  form > .col-3 { grid-column: span 3; }
  form > .col-4 { grid-column: span 4; }
  form > .col-6 { grid-column: span 6; }
  form > .col-12 { grid-column: span 12; }

  label { display:block; font-size:12px; color: var(--text-dim); margin: 2px 0 6px; }
  .help { font-size:11px; color: var(--text-dim); margin-top:6px; }
  .error { font-size:11px; color: var(--danger); margin-top:4px; display:none; }

  input, select, button, textarea {
    width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--panel-border);
    background: rgba(255,255,255,0.06); color: var(--text); outline:none;
  }
  textarea { resize: vertical; min-height: 38px; }
  input::placeholder, textarea::placeholder { color: #9aa2b4; opacity: .8; }

  /* Selects - ensure visibility on dark */
  select {
    appearance: none;
    background-image:
      linear-gradient(45deg, transparent 50%, var(--text) 50%),
      linear-gradient(135deg, var(--text) 50%, transparent 50%);
    background-position: calc(100% - 18px) 16px, calc(100% - 12px) 16px;
    background-size: 6px 6px, 6px 6px; background-repeat: no-repeat;
    color: var(--text); background: var(--panel-2); border-color: var(--panel-border);
  }
  select option, select optgroup { color: var(--text); background: var(--bg); }
  select:focus { outline: none; box-shadow: 0 0 0 3px rgba(136,224,195,.20); border-color: var(--accent-2); }
  @supports (color-scheme: dark) { select, option { color-scheme: dark; } }

  button { cursor:pointer; border:1px solid var(--panel-border); transition: transform .05s ease, filter .15s ease; }
  button:hover { filter: brightness(1.08); }
  button:active { transform: translateY(1px); }
  .btn-accent { background: linear-gradient(135deg, var(--accent), var(--accent-2)); color:#0d0f12; border:none; font-weight: 600; }
  .btn-danger { color: #fff; background: var(--danger); border: none; }
  .btn-mini { padding: 6px 10px; font-size: 12px; border-radius:8px; }
  .btn-small {
    padding: 8px 12px;
    font-size: 13px;
    border-radius: 10px;
    background: rgba(255,255,255,0.06);
  }

  .controls { padding: 12px 16px; margin-top: 12px; }
  .controls > * { grid-column: span 3; }
  .controls .group { display:flex; gap:8px; flex-wrap: wrap; }

  table { width: 100%; border-collapse: collapse; }
  thead th {
    position: sticky; top: 0; background: var(--panel-2);
    backdrop-filter: blur(6px); border-bottom: 1px solid var(--panel-border);
    padding: 10px; text-align: left; font-weight: 600; user-select: none; cursor: pointer;
  }
  tbody td { padding: 12px 10px; border-bottom: 1px solid var(--panel-border); vertical-align: top; }
  tr:hover td { background: rgba(255,255,255,0.04); }

  .pill { display:inline-block; font-size:11px; padding:3px 8px; border-radius:999px; background:#151822; border:1px solid var(--panel-border); }
  .pill.win  { background: rgba(142,230,138,0.15); border-color: rgba(142,230,138,0.35); }
  .pill.loss { background: rgba(255,107,107,0.15); border-color: rgba(255,107,107,0.35); }
  .pill.draw { background: rgba(124,140,255,0.15); border-color: rgba(124,140,255,0.35); }
  .pill.side { background: rgba(255,255,255,.06); }

  .row-actions { white-space: nowrap; display:flex; gap:6px; }

  .stats { display:grid; grid-template-columns: repeat(12,1fr); gap:12px; margin-top:14px; }
  .stat-card { grid-column: span 4; padding:14px; border-radius:12px; border:1px solid var(--panel-border); background: var(--panel); }
  .stat-title { font-size:12px; color: var(--text-dim); margin-bottom:6px; }
  .stat-value { font-size:22px; font-weight:700; }
  .stat-sub { font-size:12px; color: var(--text-dim); }

  .stat-wide { grid-column: span 8; }
  .stat-full { grid-column: span 12; }

  /* Modal for export choice */
  .modal {
    position: fixed; inset: 0; display: none; place-items: center;
    background: rgba(0,0,0,0.5);
  }
  .modal .sheet {
    background: var(--panel); border:1px solid var(--panel-border);
    border-radius: 14px; padding: 16px; min-width: 260px; box-shadow: var(--shadow);
  }
  .modal .sheet h3 { margin: 0 0 10px; font-size: 16px; }
  .modal .actions { display:flex; gap:8px; justify-content:flex-end; margin-top: 12px; }
  .modal .actions .spacer { flex: 1; }

  @media (max-width: 960px) {
    form > .col-3, .controls > * { grid-column: span 12; }
    .controls { gap:8px; }
    .stat-card, .stat-wide, .stat-full { grid-column: span 12; }
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="logo"></div>
    <div>
      <h1>DbD 1v1 Tracker</h1>
      <div class="muted">Dark mode, inline edits, mm:ss chase time, import/export, and deeper stats.</div>
    </div>
  </header>

  <div class="banner" id="backupBanner">
    ⚠️ You haven’t exported a backup in a while. Use <b>Export</b> (JSON or CSV) to save your data.
  </div>

  <!-- Form -->
  <section class="card">
    <form id="entryForm" novalidate>
      <div class="col-3">
        <label for="when">Time</label>
        <input id="when" name="when" type="datetime-local" required step="60" placeholder="YYYY-MM-DDTHH:MM" />
        <div class="error" id="err-when">Please enter a valid time (YYYY-MM-DDTHH:MM).</div>
      </div>
      <div class="col-3">
        <label for="killer">Killer</label>
        <input id="killer" name="killer" list="killerList" placeholder="e.g., Blight" required />
        <datalist id="killerList"></datalist>
        <div class="error" id="err-killer">Killer is required.</div>
      </div>
      <div class="col-3">
        <label for="map">Map</label>
        <input id="map" name="map" list="mapList" placeholder="e.g., The Game" required />
        <datalist id="mapList"></datalist>
        <div class="error" id="err-map">Map is required.</div>
      </div>
      <div class="col-3">
        <label for="opponent">Opponent</label>
        <input id="opponent" name="opponent" placeholder="Team/Player handle" required />
        <div class="error" id="err-opp">Opponent is required.</div>
      </div>

      <div class="col-3">
        <label for="side">Side</label>
        <select id="side" name="side" required>
          <option value="Killer">Killer</option>
          <option value="Survivor">Survivor</option>
        </select>
        <div class="error" id="err-side">Side is required.</div>
      </div>
      <div class="col-3">
        <label for="result">Result</label>
        <select id="result" name="result" required>
          <option value="Win">Win</option>
          <option value="Loss">Loss</option>
          <option value="Draw">Draw</option>
        </select>
        <div class="error" id="err-res">Result is required.</div>
      </div>
      <div class="col-3">
        <label for="chaseSec" id="chaseLabel">Chase Time (mm:ss or sec)</label>
        <input id="chaseSec" name="chaseSec" inputmode="text" placeholder="e.g., 1:12 or 72"
               title="Enter mm:ss (e.g., 1:12) or seconds (e.g., 72)" />
        <div class="help">Optional; stored as seconds and shown as mm:ss.</div>
      </div>
      <div class="col-3">
        <label>&nbsp;</label>
        <button class="btn-accent" id="addBtn" type="submit">Add Entry</button>
      </div>

      <div class="col-12">
        <label for="notes">Your notes <span class="muted">(optional)</span></label>
        <textarea id="notes" name="notes" placeholder="e.g., 3 shack mindgames, Hit early at TL"></textarea>
      </div>
    </form>
  </section>

  <!-- Controls -->
  <section class="card controls" style="margin-top:14px;">
    <!-- Row 1: search + Side filter moved up -->
    <input id="search" placeholder="Search killer/map/opponent/notes…" />
    <select id="filterSide">
      <option value="">Filter: Side (all)</option>
      <option>Killer</option><option>Survivor</option>
    </select>

    <!-- Row 1 cont.: Killer/Map/Result filters -->
    <select id="filterKiller"><option value="">Filter: Killer (all)</option></select>
    <select id="filterMap"><option value="">Filter: Map (all)</option></select>
    <select id="filterResult"><option value="">Filter: Result (all)</option><option>Win</option><option>Loss</option><option>Draw</option></select>

    <!-- Left-aligned actions: Clear All + Import + Export -->
    <div class="group" style="grid-column: span 12; justify-content:flex-start;">
      <button id="clearAll" type="button" class="btn-danger" title="Delete all local data">Clear All</button>
      <button id="importBtn" type="button" class="btn-small" title="Import JSON or CSV">Import</button>
      <button id="exportBtn" type="button" class="btn-small" title="Export JSON or CSV">Export</button>
    </div>
  </section>

  <!-- Table -->
  <section class="card" style="margin-top:14px; overflow: hidden;">
    <table id="entriesTable">
      <thead>
        <tr>
          <th data-key="when">Time</th>
          <th data-key="killer">Killer</th>
          <th data-key="map">Map</th>
          <th data-key="opponent">Opponent</th>
          <th data-key="side">Side</th>
          <th data-key="result">Result</th>
          <th data-key="chase">Chase</th>
          <th data-key="notes">Notes</th>
          <th style="width:180px;">Actions</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <!-- Stats -->
  <section class="stats">
    <div class="stat-card">
      <div class="stat-title">Overall</div>
      <div class="stat-value" id="overallWinrate">—</div>
      <div class="stat-sub" id="overallDetail">—</div>
      <div class="stat-sub" id="streakInfo">Streak: —</div>
    </div>

    <div class="stat-card stat-wide">
      <div class="stat-title">Chase Times</div>
      <div class="stat-sub" id="chaseSummary">—</div>
      <div class="stat-sub" id="chaseExtremes">—</div>
    </div>

    <div class="stat-card stat-wide">
      <div class="stat-title">Winrate as Killer (by killer you played)</div>
      <div id="tableAsKiller"></div>
    </div>

    <div class="stat-card stat-full">
      <div class="stat-title">Winrate vs Killer (when you were survivor)</div>
      <div id="tableVsKiller"></div>
    </div>

    <div class="stat-card stat-full">
      <div class="stat-title">Per-Map Winrate</div>
      <div id="tablePerMap"></div>
    </div>

    <div class="stat-card stat-full">
      <div class="stat-title">Per-Killer Averages & Best/Worst Maps</div>
      <div id="tablePerKillerCombo"></div>
    </div>
  </section>

  <p class="muted" style="margin-top:10px;">Data lives in your browser (localStorage). Use <b>Export</b> to back up.</p>
</div>

<!-- Export choice modal -->
<div class="modal" id="exportModal" aria-hidden="true">
  <div class="sheet">
    <h3>Export data</h3>
    <div class="muted">Choose a format:</div>
    <div class="actions">
      <span class="spacer"></span>
      <button type="button" class="btn-small" id="exportCsv">CSV</button>
      <button type="button" class="btn-small" id="exportJson">JSON</button>
      <button type="button" class="btn-danger" id="exportCancel">Cancel</button>
    </div>
  </div>
</div>

<script>
(function(){
  const STORAGE_KEY = 'dbd1v1_entries_v3';
  const META_KEY = 'dbd1v1_meta'; // { lastExportAt: ISO }
  const BACKUP_DAYS = 14;

  const killers = [
    "Trapper","Wraith","Hillbilly","Nurse","Shape (Myers)","Hag","Doctor","Huntress","Cannibal","Nightmare","Pig",
    "Clown","Spirit","Legion","Plague","Ghost Face","Demogorgon","Oni","Deathslinger","Pyramid Head","Blight",
    "Twins","Trickster","Nemesis","Pinhead","Artist","Onryō","Dredge","Wesker (Mastermind)","Knight","Skull Merchant",
    "Singularity","Xenomorph","Good Guy (Chucky)","Unknown","Lich","Houndmaster"
  ];
  const maps = [
    "Coal Tower (MacMillan)","Ironworks of Misery (MacMillan)","Shelter Woods (MacMillan)","Suffocation Pit (MacMillan)","Groaning Storehouse (MacMillan)",
    "Wreckers’ Yard (Autohaven)","Blood Lodge (Autohaven)","Gas Heaven (Autohaven)","Wretched Shop (Autohaven)",
    "Fractured Cowshed (Coldwind)","Rancid Abattoir (Coldwind)","Rotten Fields (Coldwind)","Thompson House (Coldwind)","Torment Creek (Coldwind)",
    "Mount Ormond Resort","Léry’s Memorial Institute","The Game (Gideon)","Midwich Elementary School","R.P.D. East Wing","R.P.D. West Wing",
    "Sanctum of Wrath (Yamaoka)","Family Residence (Yamaoka)","Mother’s Dwelling (Red Forest)","Temple of Purgation (Red Forest)",
    "Eyrie of Crows","Garden of Joy","Badham Preschool I","Badham Preschool II","Badham Preschool III","Badham Preschool IV","Badham Preschool V",
    "Dead Dawg Saloon","Grim Pantry (Backwater)","The Pale Rose (Backwater)","Haddonfield (Lampkin Lane)","Nostromo Wreckage"
  ];

  // Fill datalists
  const killerDatalist = document.getElementById('killerList');
  const mapDatalist   = document.getElementById('mapList');
  killers.forEach(k => killerDatalist.appendChild(opt(k)));
  maps.forEach(m => mapDatalist.appendChild(opt(m)));
  function opt(v){ const o=document.createElement('option'); o.value=v; return o; }

  const $ = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));

  // Elements
  const form        = $('#entryForm');
  const whenInput   = $('#when');
  const killerInput = $('#killer');
  const mapInput    = $('#map');
  const opponentInp = $('#opponent');
  const sideInput   = $('#side');
  const resultInput = $('#result');
  const chaseInput  = $('#chaseSec');
  const chaseLabel  = $('#chaseLabel');
  const notesInput  = $('#notes');

  const errWhen = $('#err-when'), errKiller = $('#err-killer'),
        errMap = $('#err-map'), errOpp = $('#err-opp'),
        errSide = $('#err-side'), errRes = $('#err-res');

  const backupBanner = $('#backupBanner');

  // Controls/table/stat targets
  const tableBody     = $('#entriesTable tbody');
  const searchInput   = $('#search');
  const filterKiller  = $('#filterKiller');
  const filterMap     = $('#filterMap');
  const filterResult  = $('#filterResult');
  const filterSide    = $('#filterSide');

  const overallWinrate = $('#overallWinrate');
  const overallDetail  = $('#overallDetail');
  const streakInfo     = $('#streakInfo');
  const chaseSummary   = $('#chaseSummary');
  const chaseExtremes  = $('#chaseExtremes');
  const tableAsKiller  = $('#tableAsKiller');
  const tableVsKiller  = $('#tableVsKiller');
  const tablePerMap    = $('#tablePerMap');
  const tablePerKillerCombo = $('#tablePerKillerCombo');

  // Export modal
  const exportModal = $('#exportModal');
  const exportBtn   = $('#exportBtn');
  const exportJson  = $('#exportJson');
  const exportCsv   = $('#exportCsv');
  const exportCancel= $('#exportCancel');
  const importBtn   = $('#importBtn');

  // --- Time helpers ---
  function toLocalDatetimeInputValue(d) {
    const pad = n => String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }
  function readWhenInput(el) {
    const v = (el.value || '').trim();
    if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(v)) {
      const [date, time] = v.split('T');
      const [Y,M,D] = date.split('-').map(Number);
      const [H,Min] = time.split(':').map(Number);
      return new Date(Y, M-1, D, H, Min);
    }
    const d = new Date(v);
    return isNaN(d) ? null : d;
  }
  whenInput.value = toLocalDatetimeInputValue(new Date());

  // Update chase label by side
  sideInput.addEventListener('change', ()=>{
    chaseLabel.textContent = sideInput.value === 'Killer'
      ? 'Chase Time (mm:ss or sec) — as Killer'
      : 'Chase Time (mm:ss or sec) — as Survivor';
  });
  sideInput.dispatchEvent(new Event('change'));

  // Load
  let entries = load();
  let sortKey = 'when', sortDir = 'desc';

  // Backup banner
  showBackupBanner();

  function showBackupBanner(){
    try {
      const meta = JSON.parse(localStorage.getItem(META_KEY) || '{}');
      const last = meta.lastExportAt ? new Date(meta.lastExportAt) : null;
      const now = new Date();
      const diffDays = last ? Math.floor((now - last)/86400000) : Infinity;
      backupBanner.style.display = (entries.length && diffDays >= BACKUP_DAYS) ? 'block' : 'none';
    } catch { backupBanner.style.display = 'none'; }
  }

  function load(){
    try { const v = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]'); if (Array.isArray(v)) return v; }
    catch {}
    return [];
  }
  function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(entries)); }

  // Helpers
  function parseDurationToSeconds(v){
    const s = String(v||'').trim();
    if (!s) return null;
    const mmss = /^(\d{1,3}):([0-5]?\d)$/;
    const m = s.match(mmss);
    if (m) return parseInt(m[1],10)*60 + parseInt(m[2],10);
    const n = Number(s);
    if (Number.isFinite(n) && n >= 0) return Math.floor(n);
    return null;
  }
  function formatSecondsToMMSS(n){
    if (n == null || !Number.isFinite(n)) return '—';
    const mins = Math.floor(n/60), secs = n % 60;
    return `${mins}:${String(secs).padStart(2,'0')}`;
  }
  function fmtTime(iso){
    const d = new Date(iso);
    return isNaN(d) ? iso : d.toLocaleString();
  }
  function esc(s){
    return String(s).replace(/[&<>"']/g, c => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[c]));
  }
  function normSide(s){
    const t = String(s||'').toLowerCase();
    if (t.startsWith('k')) return 'Killer';
    if (t.startsWith('s')) return 'Survivor';
    return 'Unknown';
  }
  function normalizeResult(s){
    const t = (s||'').trim().toLowerCase();
    if (t.startsWith('w')) return 'Win';
    if (t.startsWith('l')) return 'Loss';
    if (t.startsWith('d')) return 'Draw';
    return 'Draw';
  }
  function median(nums){
    if (!nums.length) return null;
    const a = nums.slice().sort((x,y)=>x-y);
    const mid = Math.floor(a.length/2);
    return a.length%2 ? a[mid] : Math.round((a[mid-1]+a[mid])/2);
  }
  function groupBy(arr, keyFn){
    const map = new Map();
    for (const it of arr){
      const k = keyFn(it);
      if (!map.has(k)) map.set(k, []);
      map.get(k).push(it);
    }
    return Array.from(map.entries()).map(([key,items])=>({key,items}))
      .sort((a,b)=>String(a.key).localeCompare(String(b.key)));
  }
  function winrate(items){
    const wl = items.filter(e=>e.result==='Win'||e.result==='Loss');
    if (!wl.length) return null;
    const w = wl.filter(e=>e.result==='Win').length;
    return (w / wl.length) * 100;
  }
  function pctFmt(x){ return x==null ? '—' : `${x.toFixed(1)}%`; }

  // Validation helpers
  function setError(el, errEl, ok){
    if (ok){ errEl.style.display='none'; el.style.borderColor = 'var(--panel-border)'; }
    else { errEl.style.display='block'; el.style.borderColor = 'var(--danger)'; }
  }

  // Submit
  form.addEventListener('submit', (e)=>{
    e.preventDefault();
    const when = readWhenInput(whenInput);
    setError(whenInput, errWhen, !!when);
    setError(killerInput, errKiller, !!killerInput.value.trim());
    setError(mapInput, errMap, !!mapInput.value.trim());
    setError(opponentInp, errOpp, !!opponentInp.value.trim());
    setError(sideInput, errSide, !!sideInput.value);
    setError(resultInput, errRes, !!resultInput.value);

    if (!when || !killerInput.value.trim() || !mapInput.value.trim() || !opponentInp.value.trim() || !sideInput.value || !resultInput.value) return;

    const side = sideInput.value;
    const chase = parseDurationToSeconds(chaseInput.value);
    const entry = {
      id: crypto.randomUUID(),
      when: when.toISOString(),
      killer: killerInput.value.trim(),
      map: mapInput.value.trim(),
      opponent: opponentInp.value.trim(),
      side,
      result: resultInput.value,
      chaseSurvivor: side === 'Survivor' ? chase : null,
      chaseKiller:   side === 'Killer'   ? chase : null,
      notes: notesInput.value.trim()
    };
    entries.push(entry);
    save();
    renderAll();

    whenInput.value = toLocalDatetimeInputValue(new Date());
    sideInput.value = 'Killer';
    sideInput.dispatchEvent(new Event('change'));
    killerInput.focus();
    chaseInput.value = '';
    notesInput.value = '';
  });

  // Render table with inline editing
  function renderTable(){
    buildFilters();

    const q  = searchInput.value.toLowerCase();
    const fk = filterKiller.value, fm = filterMap.value, fr = filterResult.value, fs = filterSide.value;

    let view = entries.slice();
    view.sort((a,b)=>{
      const va = a[sortKey] ?? '', vb = b[sortKey] ?? '';
      if (sortKey === 'when') return sortDir === 'asc' ? va.localeCompare(vb) : vb.localeCompare(va);
      return sortDir === 'asc' ? String(va).localeCompare(String(vb)) : String(vb).localeCompare(String(va));
    });

    if (q) view = view.filter(r =>
      (r.killer||'').toLowerCase().includes(q) ||
      (r.map||'').toLowerCase().includes(q) ||
      (r.opponent||'').toLowerCase().includes(q) ||
      (r.notes||'').toLowerCase().includes(q)
    );
    if (fk) view = view.filter(r => r.killer === fk);
    if (fm) view = view.filter(r => r.map === fm);
    if (fr) view = view.filter(r => r.result === fr);
    if (fs) view = view.filter(r => r.side === fs);

    tableBody.innerHTML = '';
    for (const r of view) {
      const tr = document.createElement('tr');
      tr.dataset.id = r.id;
      const resClass = (r.result||'').toLowerCase();
      const chaseSec = r.side === 'Killer' ? r.chaseKiller : r.side === 'Survivor' ? r.chaseSurvivor : null;

      tr.innerHTML = `
        <td data-col="when">${fmtTime(r.when)}</td>
        <td data-col="killer"><span class="pill">${esc(r.killer)}</span></td>
        <td data-col="map">${esc(r.map)}</td>
        <td data-col="opponent">${esc(r.opponent)}</td>
        <td data-col="side"><span class="pill side">${esc(r.side||'Unknown')}</span></td>
        <td data-col="result"><span class="pill ${resClass}">${esc(r.result||'')}</span></td>
        <td data-col="chase">${formatSecondsToMMSS(chaseSec)}</td>
        <td data-col="notes">${esc(r.notes || '')}</td>
        <td class="row-actions">
          <button class="btn-mini" data-action="edit">Edit</button>
          <button class="btn-mini" data-action="save" style="display:none;">Save</button>
          <button class="btn-mini" data-action="cancel" style="display:none;">Cancel</button>
          <button class="btn-mini btn-danger" data-action="del">Delete</button>
        </td>
      `;
      tableBody.appendChild(tr);
    }
  }

  function toEditRow(tr){
    const id = tr.dataset.id;
    const r = entries.find(e=>e.id===id); if (!r) return;

    const whenLocal = toLocalDatetimeInputValue(new Date(r.when));
    const chaseSec = r.side==='Killer' ? r.chaseKiller : r.side==='Survivor' ? r.chaseSurvivor : null;
    const chaseShown = chaseSec==null ? '' : formatSecondsToMMSS(chaseSec);

    tr.querySelector('[data-col="when"]').innerHTML =
      `<input type="datetime-local" value="${whenLocal}" step="60" class="cell-input" />`;
    tr.querySelector('[data-col="killer"]').innerHTML =
      `<input list="killerList" value="${esc(r.killer)}" class="cell-input" />`;
    tr.querySelector('[data-col="map"]').innerHTML =
      `<input list="mapList" value="${esc(r.map)}" class="cell-input" />`;
    tr.querySelector('[data-col="opponent"]').innerHTML =
      `<input value="${esc(r.opponent)}" class="cell-input" />`;
    tr.querySelector('[data-col="side"]').innerHTML =
      `<select class="cell-input">
        <option ${r.side==='Killer'?'selected':''}>Killer</option>
        <option ${r.side==='Survivor'?'selected':''}>Survivor</option>
      </select>`;
    tr.querySelector('[data-col="result"]').innerHTML =
      `<select class="cell-input">
        <option ${r.result==='Win'?'selected':''}>Win</option>
        <option ${r.result==='Loss'?'selected':''}>Loss</option>
        <option ${r.result==='Draw'?'selected':''}>Draw</option>
      </select>`;
    tr.querySelector('[data-col="chase"]').innerHTML =
      `<input value="${esc(chaseShown)}" placeholder="mm:ss or sec" class="cell-input" />`;
    tr.querySelector('[data-col="notes"]').innerHTML =
      `<textarea class="cell-input">${esc(r.notes||'')}</textarea>`;

    toggleRowButtons(tr, true);
  }
  function cancelEditRow(tr){
    toggleRowButtons(tr, false);
    renderTable();
  }
  function saveEditRow(tr){
    const id = tr.dataset.id;
    const idx = entries.findIndex(e=>e.id===id); if (idx<0) return;
    const r = entries[idx];

    const get = col => tr.querySelector(`[data-col="${col}"] .cell-input`);
    const whenVal = get('when').value;
    const when = readWhenInput({value: whenVal});
    const killerVal = (get('killer').value||'').trim();
    const mapVal = (get('map').value||'').trim();
    const oppVal = (get('opponent').value||'').trim();
    const sideVal = normSide(get('side').value);
    const resVal = normalizeResult(get('result').value);
    const chaseVal = parseDurationToSeconds(get('chase').value);
    const notesVal = (get('notes').value||'').trim();

    if (!when || !killerVal || !mapVal || !oppVal) {
      alert('Please fill Time, Killer, Map, and Opponent with valid values.');
      return;
    }
    r.when = when.toISOString();
    r.killer = killerVal;
    r.map = mapVal;
    r.opponent = oppVal;
    r.side = sideVal;
    r.result = resVal;
    r.chaseSurvivor = sideVal==='Survivor' ? chaseVal : null;
    r.chaseKiller   = sideVal==='Killer'   ? chaseVal : null;
    r.notes = notesVal;

    save();
    toggleRowButtons(tr, false);
    renderAll();
  }
  function toggleRowButtons(tr, editing){
    const btnEdit = tr.querySelector('[data-action="edit"]');
    const btnSave = tr.querySelector('[data-action="save"]');
    const btnCancel = tr.querySelector('[data-action="cancel"]');
    if (!btnEdit) return;
    btnEdit.style.display = editing ? 'none' : '';
    btnSave.style.display = editing ? '' : 'none';
    btnCancel.style.display = editing ? '' : 'none';
  }

  // Sorting
  $$('#entriesTable thead th[data-key]').forEach(th=>{
    th.addEventListener('click', ()=>{
      const key = th.dataset.key;
      if (sortKey === key) sortDir = (sortDir === 'asc' ? 'desc' : 'asc');
      else { sortKey = key; sortDir = key === 'when' ? 'desc' : 'asc'; }
      renderTable();
    });
  });

  // Row actions
  tableBody.addEventListener('click', (e)=>{
    const btn = e.target.closest('button[data-action]');
    if (!btn) return;
    const tr = btn.closest('tr');
    if (btn.dataset.action === 'del') {
      if (confirm('Delete this entry?')) {
        const id = tr.dataset.id;
        entries = entries.filter(r=>r.id!==id);
        save(); renderAll();
      }
    } else if (btn.dataset.action === 'edit') {
      toEditRow(tr);
    } else if (btn.dataset.action === 'save') {
      saveEditRow(tr);
    } else if (btn.dataset.action === 'cancel') {
      cancelEditRow(tr);
    }
  });

  function buildFilters(){
    const killersSet = [...new Set(entries.map(e=>e.killer).filter(Boolean))].sort();
    const mapsSet    = [...new Set(entries.map(e=>e.map).filter(Boolean))].sort();

    const kVal = filterKiller.value, mVal = filterMap.value, sVal = filterSide.value, rVal = filterResult.value;

    filterKiller.innerHTML = `<option value="">Filter: Killer (all)</option>` + killersSet.map(k=>`<option>${esc(k)}</option>`).join('');
    filterMap.innerHTML    = `<option value="">Filter: Map (all)</option>` + mapsSet.map(m=>`<option>${esc(m)}</option>`).join('');

    // keep selected values when rebuilding
    if (kVal && killersSet.includes(kVal)) filterKiller.value = kVal;
    if (mVal && mapsSet.includes(mVal))    filterMap.value    = mVal;
    if (sVal) filterSide.value = sVal;
    if (rVal) filterResult.value = rVal;
  }

  // --- Export & Import (buttons) ---
  function markExported(){
    localStorage.setItem(META_KEY, JSON.stringify({ lastExportAt: new Date().toISOString() }));
    showBackupBanner();
  }
  function downloadBlob(text, filename, mime){
    const blob = new Blob([text], {type:mime});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename; a.click();
    URL.revokeObjectURL(a.href);
  }
  function csvCell(s){ const t = String(s).replace(/"/g,'""'); return /[",\n]/.test(t) ? `"${t}"` : t; }
  function stamp(){
    const d = new Date(); const p = n => String(n).padStart(2,'0');
    return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}`;
  }

  // Export modal handlers
  exportBtn.addEventListener('click', () => {
    exportModal.style.display = 'grid';
    exportModal.setAttribute('aria-hidden','false');
  });
  exportCancel.addEventListener('click', closeExport);
  exportModal.addEventListener('click', (e) => {
    if (e.target === exportModal) closeExport(); // click outside sheet closes
  });
  function closeExport(){
    exportModal.style.display = 'none';
    exportModal.setAttribute('aria-hidden','true');
  }

  // Export JSON
  exportJson.addEventListener('click', ()=>{
    const payload = { schema: 'dbd1v1.v3', exportedAt: new Date().toISOString(), entries };
    downloadBlob(JSON.stringify(payload, null, 2), `dbd-1v1-tracker-${stamp()}.json`, 'application/json;charset=utf-8;');
    closeExport(); markExported();
  });
  // Export CSV
  exportCsv.addEventListener('click', ()=>{
    const header = ['id','when','killer','map','opponent','side','result','chaseSurvivor','chaseKiller','notes'];
    const lines = [header.join(',')];
    for (const r of entries) lines.push(header.map(k => csvCell(r[k] ?? '')).join(','));
    downloadBlob(lines.join('\n'), `dbd-1v1-tracker-${stamp()}.csv`, 'text/csv;charset=utf-8;');
    closeExport(); markExported();
  });

  // Import (auto-detect JSON or CSV)
  importBtn.addEventListener('click', async ()=>{
    const [file] = await openFile('.json,.csv,application/json,text/csv'); if (!file) return;
    const name = (file.name || '').toLowerCase();
    const text = await file.text();
    try {
      if (name.endsWith('.json')) {
        importFromJson(text);
      } else if (name.endsWith('.csv')) {
        importFromCsv(text);
      } else {
        // Try to sniff
        if (text.trim().startsWith('{') || text.trim().startsWith('[')) importFromJson(text);
        else importFromCsv(text);
      }
    } catch (e) {
      alert('Import failed: ' + e.message);
    }
  });

  function importFromJson(text){
    const obj = JSON.parse(text);
    const list = Array.isArray(obj) ? obj : (Array.isArray(obj.entries) ? obj.entries : []);
    if (!Array.isArray(list)) throw new Error('JSON must be an array or {entries:[]}');
    const byId = new Map(entries.map(e=>[e.id,e]));
    let added=0, updated=0;
    for (const r of list) {
      const s = sanitize(r);
      if (!s) continue;
      byId.set(s.id, s);
      if (entries.find(e=>e.id===s.id)) updated++; else added++;
    }
    entries = Array.from(byId.values());
    save(); renderAll();
    alert(`Imported ${added} new, updated ${updated}.`);
  }

  function parseCsv(text){
    const rows = []; let row = [], cell = '', inQ = false;
    for (let i=0;i<text.length;i++){
      const c = text[i], n = text[i+1];
      if (inQ){
        if (c === '"' && n === '"'){ cell += '"'; i++; }
        else if (c === '"'){ inQ = false; }
        else { cell += c; }
      } else {
        if (c === '"' ){ inQ = true; }
        else if (c === ','){ row.push(cell); cell=''; }
        else if (c === '\n'){ row.push(cell); rows.push(row); row=[]; cell=''; }
        else if (c === '\r'){ }
        else { cell += c; }
      }
    }
    if (cell.length || row.length) { row.push(cell); rows.push(row); }
    return rows;
  }

  function importFromCsv(text){
    const rows = parseCsv(text);
    const header = rows.shift() || [];
    const idx = (name) => header.indexOf(name);
    const idIx=idx('id'), whenIx=idx('when'), kIx=idx('killer'), mIx=idx('map'),
          oIx=idx('opponent'), sIx=idx('side'), rIx=idx('result'),
          csIx=idx('chaseSurvivor'), ckIx=idx('chaseKiller'), nIx=idx('notes');
    if ([idIx,whenIx,kIx,mIx,oIx,sIx,rIx,csIx,ckIx,nIx].some(i=>i===-1)){
      throw new Error('CSV must include id,when,killer,map,opponent,side,result,chaseSurvivor,chaseKiller,notes');
    }
    const byId = new Map(entries.map(e=>[e.id,e]));
    let added=0, updated=0;
    for (const r of rows) {
      const obj = sanitize({
        id: r[idIx] || crypto.randomUUID(),
        when: r[whenIx],
        killer: r[kIx],
        map: r[mIx],
        opponent: r[oIx],
        side: r[sIx],
        result: r[rIx],
        chaseSurvivor: r[csIx]? Number(r[csIx]) : null,
        chaseKiller:   r[ckIx]? Number(r[ckIx]) : null,
        notes: r[nIx] || ''
      });
      if (!obj) continue;
      if (byId.has(obj.id)) { byId.set(obj.id, obj); updated++; }
      else { byId.set(obj.id, obj); added++; }
    }
    entries = Array.from(byId.values());
    save(); renderAll();
    alert(`Imported ${added} new, updated ${updated}.`);
  }

  // File helpers
  function openFile(accept){
    return new Promise((resolve)=>{
      const inp = document.createElement('input');
      inp.type = 'file'; if (accept) inp.accept = accept;
      inp.addEventListener('change', ()=> resolve(inp.files || []), {once:true});
      inp.click();
    });
  }

  function sanitize(r){
    try {
      const id  = r.id || crypto.randomUUID();
      const when = new Date(r.when || r.time || Date.now()); if (isNaN(when)) return null;
      const killer = String(r.killer||'').trim();
      const map    = String(r.map||'').trim();
      const opponent = String(r.opponent||'').trim();
      const side   = normSide(r.side || 'Unknown');
      const result = normalizeResult(r.result || 'Draw');
      const cs = r.chaseSurvivor == null ? null : Number(r.chaseSurvivor);
      const ck = r.chaseKiller   == null ? null : Number(r.chaseKiller);
      const notes = String(r.notes||'').trim();
      if (!killer || !map || !opponent) return null;
      return { id, when: when.toISOString(), killer, map, opponent, side, result, chaseSurvivor: cs, chaseKiller: ck, notes };
    } catch { return null; }
  }

  // Stats
  function renderStats(){
    const onlyWL = entries.filter(e => e.result === 'Win' || e.result === 'Loss');
    const wins = onlyWL.filter(e => e.result === 'Win').length;
    const losses = onlyWL.filter(e => e.result === 'Loss').length;
    const draws = entries.filter(e => e.result === 'Draw').length;
    const winrateOverall = onlyWL.length ? (wins/onlyWL.length)*100 : 0;
    overallWinrate.textContent = onlyWL.length ? `${winrateOverall.toFixed(1)}%` : '—';
    overallDetail.textContent = `${wins}W / ${losses}L ${draws?`/ ${draws}D`:''} across ${entries.length} matches`;

    // Streak (latest to earliest in time)
    const sortedByTime = entries.slice().sort((a,b)=> b.when.localeCompare(a.when));
    let streakType = null, streakLen = 0;
    for (const r of sortedByTime){
      if (r.result==='Draw') continue;
      if (!streakType) { streakType = r.result; streakLen = 1; }
      else if (r.result === streakType) { streakLen++; }
      else break;
    }
    streakInfo.textContent = `Streak: ${streakLen? (streakType==='Win'? 'W':'L')+streakLen : '—'}`;

    // Chase summary (both roles combined)
    const allChase = entries.map(e => e.side==='Killer'? e.chaseKiller : e.side==='Survivor'? e.chaseSurvivor : null)
      .filter(n => Number.isFinite(n));
    const avgAll = allChase.length ? Math.round(allChase.reduce((a,b)=>a+b,0)/allChase.length) : null;
    const medAll = median(allChase);
    chaseSummary.textContent = allChase.length
      ? `Avg ${formatSecondsToMMSS(avgAll)} • Median ${formatSecondsToMMSS(medAll)} • N=${allChase.length}`
      : '—';
    if (allChase.length){
      const min = Math.min(...allChase), max = Math.max(...allChase);
      chaseExtremes.textContent = `Shortest ${formatSecondsToMMSS(min)} • Longest ${formatSecondsToMMSS(max)}`;
    } else {
      chaseExtremes.textContent = '—';
    }

    // As Killer (you played killer)
    const asKiller = entries.filter(e => e.side === 'Killer');
    tableAsKiller.innerHTML = buildAggTable(
      groupBy(asKiller, e => e.killer),
      row => ({
        label: row.key,
        played: row.items.filter(e => e.result==='Win'||e.result==='Loss').length,
        wins: row.items.filter(e => e.result==='Win').length,
        losses: row.items.filter(e => e.result==='Loss').length,
        winrate: pctFmt(winrate(row.items)),
        avgChase: avgSec(row.items.map(e=>e.chaseKiller).filter(Number.isFinite)),
        medChase: medSec(row.items.map(e=>e.chaseKiller).filter(Number.isFinite))
      }),
      ['Killer','Played','Wins','Losses','Win%','Avg chase','Med chase']
    );

    // Versus Killer (you were survivor)
    const vsKiller = entries.filter(e => e.side === 'Survivor');
    tableVsKiller.innerHTML = buildAggTable(
      groupBy(vsKiller, e => e.killer),
      row => ({
        label: row.key,
        played: row.items.filter(e => e.result==='Win'||e.result==='Loss').length,
        wins: row.items.filter(e => e.result==='Win').length,
        losses: row.items.filter(e => e.result==='Loss').length,
        winrate: pctFmt(winrate(row.items)),
        avgChase: avgSec(row.items.map(e=>e.chaseSurvivor).filter(Number.isFinite)),
        medChase: medSec(row.items.map(e=>e.chaseSurvivor).filter(Number.isFinite))
      }),
      ['Killer','Played','Wins','Losses','Win%','Avg chase','Med chase']
    );

    // Per-map winrate (both sides)
    tablePerMap.innerHTML = buildAggTable(
      groupBy(entries, e => e.map),
      row => ({
        label: row.key,
        played: row.items.filter(e => e.result==='Win'||e.result==='Loss').length,
        wins: row.items.filter(e => e.result==='Win').length,
        losses: row.items.filter(e => e.result==='Loss').length,
        winrate: pctFmt(winrate(row.items))
      }),
      ['Map','Played','Wins','Losses','Win%']
    );

    // Per-killer combined overview (avg chase on both sides + best/worst map)
    const byKillerAll = groupBy(entries, e => e.killer);
    tablePerKillerCombo.innerHTML = buildAggTable(
      byKillerAll,
      row => {
        const items = row.items;
        const asK = items.filter(e=>e.side==='Killer');
        const vsK = items.filter(e=>e.side==='Survivor');

        const avgK = avgSec(asK.map(e=>e.chaseKiller).filter(Number.isFinite));
        const avgS = avgSec(vsK.map(e=>e.chaseSurvivor).filter(Number.isFinite));

        // group by map across ALL matches with this killer (both sides)
        const byMap = groupBy(items, it => it.map).map(g => {
          const wr = winrate(g.items);
          const nWl = g.items.filter(x=>x.result==='Win'||x.result==='Loss').length;
          return { map: g.key, wr, nWl };
        }).filter(x => x.nWl > 0);

        let best = '—', worst = '—';
        if (byMap.length) {
          const desc = byMap.slice().sort((a,b)=> (b.wr??-1)-(a.wr??-1) || b.nWl - a.nWl || a.map.localeCompare(b.map));
          const asc  = byMap.slice().sort((a,b)=> (a.wr??999)-(b.wr??999) || b.nWl - a.nWl || a.map.localeCompare(b.map));
          const b = desc[0], w = asc[0];
          best  = `${b.map} (${pctFmt(b.wr)}; n=${b.nWl})`;
          worst = `${w.map} (${pctFmt(w.wr)}; n=${w.nWl})`;
        }

        return {
          label: row.key,
          avgKillerChase: avgK,
          avgSurvChase: avgS,
          bestMap: best,
          worstMap: worst
        };
      },
      ['Killer','Avg chase (K)','Avg chase (S)','Best Map','Worst Map']
    );
  }

  function avgSec(nums){
    if (!nums.length) return '—';
    const s = nums.reduce((a,b)=>a+b,0);
    return formatSecondsToMMSS(Math.round(s/nums.length));
  }
  function medSec(nums){
    if (!nums.length) return '—';
    return formatSecondsToMMSS(median(nums));
  }
  function buildAggTable(rows, mapRow, headers){
    if (rows.length === 0) return `<div class="muted">No data yet.</div>`;
    const mapped = rows.map(mapRow);
    const head = `<thead><tr>${headers.map(h=>`<th style="text-align:left;padding:8px 6px;">${h}</th>`).join('')}</tr></thead>`;
    const body = `<tbody>${mapped.map(r=>`
      <tr>
        <td style="padding:8px 6px;">${esc(r.label)}</td>
        ${r.played!==undefined ? `<td style="padding:8px 6px;">${esc(r.played)}</td>` : ''}
        ${r.wins!==undefined ? `<td style="padding:8px 6px;">${esc(r.wins)}</td>` : ''}
        ${r.losses!==undefined ? `<td style="padding:8px 6px;">${esc(r.losses)}</td>` : ''}
        ${r.winrate!==undefined ? `<td style="padding:8px 6px;">${esc(r.winrate)}</td>` : ''}
        ${r.avgChase!==undefined ? `<td style="padding:8px 6px;">${esc(r.avgChase)}</td>` : ''}
        ${r.medChase!==undefined ? `<td style="padding:8px 6px;">${esc(r.medChase)}</td>` : ''}
        ${r.avgKillerChase!==undefined ? `<td style="padding:8px 6px;">${esc(r.avgKillerChase)}</td>` : ''}
        ${r.avgSurvChase!==undefined ? `<td style="padding:8px 6px;">${esc(r.avgSurvChase)}</td>` : ''}
        ${r.bestMap!==undefined ? `<td style="padding:8px 6px;">${esc(r.bestMap)}</td>` : ''}
        ${r.worstMap!==undefined ? `<td style="padding:8px 6px;">${esc(r.worstMap)}</td>` : ''}
      </tr>`).join('')}</tbody>`;
    return `<table style="width:100%;border-collapse:collapse;border:1px solid var(--panel-border);">${head}${body}</table>`;
  }

  // Live search & filters
  searchInput.addEventListener('input', renderAll);
  [filterKiller, filterMap, filterResult, filterSide].forEach(el=> el.addEventListener('change', renderAll));

  // Clear all
  $('#clearAll').addEventListener('click', ()=>{
    if (!entries.length) return alert('Nothing to clear.');
    if (confirm('This will delete ALL saved entries on this device. Continue?')) { entries = []; save(); renderAll(); }
  });

  function renderAll(){ renderTable(); renderStats(); }

  // Initial render
  renderAll();
})();
</script>
</body>
</html>
